[{"content":"HUGO+GitHub Action deploy your own Blog Prerequisites Install Hugo (Extended version) in macos 1 brew install hugo Git installed GitHub account Step 1: Create a New Hugo Site 1 2 3 4 5 6 # Create a new Hugo site hugo new site myblog cd myblog # Initialize git repository git init Step 2: Add a Theme Choose and install a Hugo theme in https://themes.gohugo.io/. For example, using stack theme:\nTo use the latest version, you can clone the repository to themes/hugo-theme-stack by running the following command in the root directory of your Hugo site:\n1 git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack If you are already using Git for your site, you can add the theme as a submodule by running the following command in the root directory of your Hugo site:\n1 git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod Step 3: Configure Your Site Create or modify hugo.toml/hugo.yaml with basic settings,for here, i just copy and paste the example hugo.yaml from exampleSite included in the theme. you can also transform between .yaml file and .toml file in following website. https://transform.tools/toml-to-yaml/.\nStep 4: Create Content HUGO primarily support Markdown and HTML file for content creation you can also generate a default post in command line.\n1 2 # Create your first post hugo new posts/my-first-post.md Step 5: Setup GitHub Actions Create .github/workflows/deploy.yml in your repository:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 name: Deploy Hugo site to Pages on: push: branches: [\u0026#34;main\u0026#34;] workflow_dispatch: permissions: contents: read pages: write id-token: write concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false defaults: run: shell: bash jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 with: submodules: recursive - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build run: hugo --minify - name: Upload artifact uses: actions/upload-pages-artifact@v2 with: path: ./public deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v2 Step 6: Deploy Push your code to GitHub repository Enable GitHub Pages in repository settings Set the source to GitHub Actions 1 2 3 4 5 git add . git commit -m \u0026#34;Initial commit\u0026#34; git branch -M main git remote add origin https://github.com/username/repository.git git push -u origin main Your blog should now be accessible at https://yourusername.github.io/\nImportant Notes Make sure your repository name follows the format: username.github.io Wait a few minutes after pushing for GitHub Actions to complete the deployment Check the Actions tab in your GitHub repository for deployment status ","date":"2024-12-05T00:00:00Z","image":"http://localhost:1313/p/how-to-start-a-blog-in-2024/cover_hu16594101523886342873.jpg","permalink":"http://localhost:1313/p/how-to-start-a-blog-in-2024/","title":"How to Start A Blog in 2024"},{"content":"Dotnet async await: whenall,cancletoken\n接口不要声明 async\nLINQ 扩展方法(实现了 I) 依赖注入 服务:对象要的框架\n服务容器:管理注册的服务 查询服务:查询对象以及关联对象\n对象的生命周期: 瞬态: 获取一次 NEW 一个新的对象 范围:在这个范围内用的是同一个对象 单例:无论谁获取这个服务都是这个对象\n配置\nIQueryable 和 IEnumerable 的区别 IENUMBERABLE is executed in the local memory, the other one is complied into the SQL script and executed in the databased server.\nso when the number of the query is large, we need to use the Iqueryable because the server tend to have better performance than the local machine\nhow to traverse the IQUERYABLE async upsetting.json,配置文件 function reload 之后进行热重载\n使用 configuration 映射配置类 环境变量的优先级 Command-line arguments \u0026gt; Environment variables \u0026gt; User secrets \u0026gt; Configuration files (e.g., appsettings.json) \u0026gt; Default values.\nA brief history of GC in .NET The genesis of the garbage collector (GC) in .NET dates back to 1990 when Microsoft was developing its version of JavaScript, named JScript. Initially developed by a four-person team, one member, Patrick Dussud, who is recognized as the father of .NET’s garbage collector, developed a Conservative GC within the team. At that time, the CLR did not exist, and Patrick was working on the JVM.\nInitially, Microsoft aimed to implement its version of the JVM instead of creating something akin to the current .NET runtime. However, once the CLR team was formed, they realized that the JVM imposed certain limitations on them, prompting the creation of their own environment.\nWith this decision, Patrick redeveloped a new GC from scratch, targeting the “best GC possible” concept, using LISP, his language of expertise. He then wrote a transpiler from LISP to C++ to make the code compatible with Microsoft’s runtime. (The birth of the CLR)\nThe current codes for the garbage collector used in .NET can be accessed from this file in Microsoft’s runtime repository. Today, Maoni Stephens, the technical lead of Microsoft’s GC team, who has written and presented many conferences and articles on various aspects of GC implementation, can be followed on her blog.\nCurrently, .NET is equipped with three modes (flavors) of GC, each optimized for different types of applications. Let’s dive into each of these:\nServer GC Optimized for server-side applications like ASP.NET Core and WCF, this variant of GC is designed for environments with high request rates and frequent object allocations and deallocations.\nServer GC operates with a separate heap and a GC thread for each processor. This means that if you have an eight-core processor, there will be an independent heap and GC thread on each core during garbage collection.\nThis approach ensures the collection process is as swift as possible without additional pauses, preventing the application from “freezing”.\nServer GC is only executable on multi-core processors. Attempting to run a server-side application in Server GC mode on a single-core processor will automatically result in a fallback to Non-Concurrent Workstation GC.\nTo use Server GC in non-server-side applications (like WPF, Windows Services, etc.) on multi-core processors, add the following settings to your app.config or web.config:\nA brief history of GC in .NET The genesis of the garbage collector (GC) in .NET dates back to 1990 when Microsoft was developing its version of JavaScript, named JScript. Initially developed by a four-person team, one member, Patrick Dussud, who is recognized as the father of .NET’s garbage collector, developed a Conservative GC within the team. At that time, the CLR did not exist, and Patrick was working on the JVM.\nInitially, Microsoft aimed to implement its version of the JVM instead of creating something akin to the current .NET runtime. However, once the CLR team was formed, they realized that the JVM imposed certain limitations on them, prompting the creation of their own environment.\nWith this decision, Patrick redeveloped a new GC from scratch, targeting the “best GC possible” concept, using LISP, his language of expertise. He then wrote a transpiler from LISP to C++ to make the code compatible with Microsoft’s runtime. (The birth of the CLR)\nThe current codes for the garbage collector used in .NET can be accessed from this file in Microsoft’s runtime repository. Today, Maoni Stephens, the technical lead of Microsoft’s GC team, who has written and presented many conferences and articles on various aspects of GC implementation, can be followed on her blog.\nCurrently, .NET is equipped with three modes (flavors) of GC, each optimized for different types of applications. Let’s dive into each of these:\nServer GC Optimized for server-side applications like ASP.NET Core and WCF, this variant of GC is designed for environments with high request rates and frequent object allocations and deallocations.\nServer GC operates with a separate heap and a GC thread for each processor. This means that if you have an eight-core processor, there will be an independent heap and GC thread on each core during garbage collection.\nThis approach ensures the collection process is as swift as possible without additional pauses, preventing the application from “freezing”.\nServer GC is only executable on multi-core processors. Attempting to run a server-side application in Server GC mode on a single-core processor will automatically result in a fallback to Non-Concurrent Workstation GC.\nTo use Server GC in non-server-side applications (like WPF, Windows Services, etc.) on multi-core processors, add the following settings to your app.config or web.config:\nA brief history of GC in .NET The genesis of the garbage collector (GC) in .NET dates back to 1990 when Microsoft was developing its version of JavaScript, named JScript. Initially developed by a four-person team, one member, Patrick Dussud, who is recognized as the father of .NET’s garbage collector, developed a Conservative GC within the team. At that time, the CLR did not exist, and Patrick was working on the JVM.\nInitially, Microsoft aimed to implement its version of the JVM instead of creating something akin to the current .NET runtime. However, once the CLR team was formed, they realized that the JVM imposed certain limitations on them, prompting the creation of their own environment.\nWith this decision, Patrick redeveloped a new GC from scratch, targeting the “best GC possible” concept, using LISP, his language of expertise. He then wrote a transpiler from LISP to C++ to make the code compatible with Microsoft’s runtime. (The birth of the CLR)\nThe current codes for the garbage collector used in .NET can be accessed from this file in Microsoft’s runtime repository. Today, Maoni Stephens, the technical lead of Microsoft’s GC team, who has written and presented many conferences and articles on various aspects of GC implementation, can be followed on her blog.\nCurrently, .NET is equipped with three modes (flavors) of GC, each optimized for different types of applications. Let’s dive into each of these:\nServer GC Optimized for server-side applications like ASP.NET Core and WCF, this variant of GC is designed for environments with high request rates and frequent object allocations and deallocations.\nServer GC operates with a separate heap and a GC thread for each processor. This means that if you have an eight-core processor, there will be an independent heap and GC thread on each core during garbage collection.\nThis approach ensures the collection process is as swift as possible without additional pauses, preventing the application from “freezing”.\nServer GC is only executable on multi-core processors. Attempting to run a server-side application in Server GC mode on a single-core processor will automatically result in a fallback to Non-Concurrent Workstation GC.\nTo use Server GC in non-server-side applications (like WPF, Windows Services, etc.) on multi-core processors, add the following settings to your app.config or web.config:\nA brief history of GC in .NET The genesis of the garbage collector (GC) in .NET dates back to 1990 when Microsoft was developing its version of JavaScript, named JScript. Initially developed by a four-person team, one member, Patrick Dussud, who is recognized as the father of .NET’s garbage collector, developed a Conservative GC within the team. At that time, the CLR did not exist, and Patrick was working on the JVM.\nInitially, Microsoft aimed to implement its version of the JVM instead of creating something akin to the current .NET runtime. However, once the CLR team was formed, they realized that the JVM imposed certain limitations on them, prompting the creation of their own environment.\nWith this decision, Patrick redeveloped a new GC from scratch, targeting the “best GC possible” concept, using LISP, his language of expertise. He then wrote a transpiler from LISP to C++ to make the code compatible with Microsoft’s runtime. (The birth of the CLR)\nThe current codes for the garbage collector used in .NET can be accessed from this file in Microsoft’s runtime repository. Today, Maoni Stephens, the technical lead of Microsoft’s GC team, who has written and presented many conferences and articles on various aspects of GC implementation, can be followed on her blog.\nCurrently, .NET is equipped with three modes (flavors) of GC, each optimized for different types of applications. Let’s dive into each of these:\nServer GC Optimized for server-side applications like ASP.NET Core and WCF, this variant of GC is designed for environments with high request rates and frequent object allocations and deallocations.\nServer GC operates with a separate heap and a GC thread for each processor. This means that if you have an eight-core processor, there will be an independent heap and GC thread on each core during garbage collection.\nThis approach ensures the collection process is as swift as possible without additional pauses, preventing the application from “freezing”.\nServer GC is only executable on multi-core processors. Attempting to run a server-side application in Server GC mode on a single-core processor will automatically result in a fallback to Non-Concurrent Workstation GC.\nTo use Server GC in non-server-side applications (like WPF, Windows Services, etc.) on multi-core processors, add the following settings to your app.config or web.config:\nA brief history of GC in .NET The genesis of the garbage collector (GC) in .NET dates back to 1990 when Microsoft was developing its version of JavaScript, named JScript. Initially developed by a four-person team, one member, Patrick Dussud, who is recognized as the father of .NET’s garbage collector, developed a Conservative GC within the team. At that time, the CLR did not exist, and Patrick was working on the JVM.\nInitially, Microsoft aimed to implement its version of the JVM instead of creating something akin to the current .NET runtime. However, once the CLR team was formed, they realized that the JVM imposed certain limitations on them, prompting the creation of their own environment.\nWith this decision, Patrick redeveloped a new GC from scratch, targeting the “best GC possible” concept, using LISP, his language of expertise. He then wrote a transpiler from LISP to C++ to make the code compatible with Microsoft’s runtime. (The birth of the CLR)\nThe current codes for the garbage collector used in .NET can be accessed from this file in Microsoft’s runtime repository. Today, Maoni Stephens, the technical lead of Microsoft’s GC team, who has written and presented many conferences and articles on various aspects of GC implementation, can be followed on her blog.\nCurrently, .NET is equipped with three modes (flavors) of GC, each optimized for different types of applications. Let’s dive into each of these:\nServer GC Optimized for server-side applications like ASP.NET Core and WCF, this variant of GC is designed for environments with high request rates and frequent object allocations and deallocations.\nServer GC operates with a separate heap and a GC thread for each processor. This means that if you have an eight-core processor, there will be an independent heap and GC thread on each core during garbage collection.\nThis approach ensures the collection process is as swift as possible without additional pauses, preventing the application from “freezing”.\nServer GC is only executable on multi-core processors. Attempting to run a server-side application in Server GC mode on a single-core processor will automatically result in a fallback to Non-Concurrent Workstation GC.\nTo use Server GC in non-server-side applications (like WPF, Windows Services, etc.) on multi-core processors, add the following settings to your app.config or web.config:\nA brief history of GC in .NET The genesis of the garbage collector (GC) in .NET dates back to 1990 when Microsoft was developing its version of JavaScript, named JScript. Initially developed by a four-person team, one member, Patrick Dussud, who is recognized as the father of .NET’s garbage collector, developed a Conservative GC within the team. At that time, the CLR did not exist, and Patrick was working on the JVM.\nInitially, Microsoft aimed to implement its version of the JVM instead of creating something akin to the current .NET runtime. However, once the CLR team was formed, they realized that the JVM imposed certain limitations on them, prompting the creation of their own environment.\nWith this decision, Patrick redeveloped a new GC from scratch, targeting the “best GC possible” concept, using LISP, his language of expertise. He then wrote a transpiler from LISP to C++ to make the code compatible with Microsoft’s runtime. (The birth of the CLR)\nThe current codes for the garbage collector used in .NET can be accessed from this file in Microsoft’s runtime repository. Today, Maoni Stephens, the technical lead of Microsoft’s GC team, who has written and presented many conferences and articles on various aspects of GC implementation, can be followed on her blog.\nCurrently, .NET is equipped with three modes (flavors) of GC, each optimized for different types of applications. Let’s dive into each of these:\nServer GC Optimized for server-side applications like ASP.NET Core and WCF, this variant of GC is designed for environments with high request rates and frequent object allocations and deallocations.\nServer GC operates with a separate heap and a GC thread for each processor. This means that if you have an eight-core processor, there will be an independent heap and GC thread on each core during garbage collection.\nThis approach ensures the collection process is as swift as possible without additional pauses, preventing the application from “freezing”.\nServer GC is only executable on multi-core processors. Attempting to run a server-side application in Server GC mode on a single-core processor will automatically result in a fallback to Non-Concurrent Workstation GC.\nTo use Server GC in non-server-side applications (like WPF, Windows Services, etc.) on multi-core processors, add the following settings to your app.config or web.config:\n","date":"2019-03-11T00:00:00Z","permalink":"http://localhost:1313/p/redis-test/","title":"redis test"}]